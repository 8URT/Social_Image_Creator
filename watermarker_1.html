<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Watermarker LM + Overlay</title>

  <link href="https://fonts.googleapis.com/css2?family=Fira+Sans:wght@700;800&display=swap" rel="stylesheet" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
(function() {
  'use strict';

  const CONFIG = {
    expectedHash: "6373f7e8a5733aa1b875ec0e46235b67b018e8fe239e47bc35d6d9b792cc3b2c",
    expiryDays: 7, // number of days before password expires
    styles: {
      overlay: {
        position: 'fixed',
        top: '0',
        left: '0',
        width: '100%',
        height: '100%',
        background: 'linear-gradient(135deg, #1a202c 0%, #2d3748 100%)',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        zIndex: '10000',
        fontFamily: "'Fira Sans', sans-serif"
      },
      container: {
        background: '#2d3748',
        padding: '40px',
        borderRadius: '20px',
        boxShadow: '0 20px 60px rgba(0,0,0,0.5)',
        textAlign: 'center',
        minWidth: '300px',
        border: '1px solid #4a5568'
      },
      title: {
        color: '#f7fafc',
        marginBottom: '30px',
        fontSize: '28px',
        fontWeight: '700',
        margin: '0 0 30px 0'
      },
      input: {
        width: '100%',
        padding: '15px 20px',
        background: '#1a202c',
        border: '2px solid #4a5568',
        borderRadius: '12px',
        color: '#f7fafc',
        fontSize: '16px',
        marginBottom: '15px',
        transition: 'all 0.3s ease',
        boxSizing: 'border-box',
        outline: 'none'
      },
      inputFocus: {
        borderColor: '#66aaff',
        boxShadow: '0 0 0 3px rgba(102, 170, 255, 0.3)'
      },
      button: {
        width: '100%',
        padding: '15px',
        background: 'linear-gradient(135deg, #66aaff 0%, #4299e1 100%)',
        border: 'none',
        borderRadius: '12px',
        color: '#f7fafc',
        fontSize: '16px',
        fontWeight: '700',
        cursor: 'pointer',
        transition: 'all 0.3s ease'
      },
      buttonHover: {
        transform: 'translateY(-2px)',
        boxShadow: '0 10px 25px rgba(102, 170, 255, 0.4)'
      },
      error: {
        color: '#fc8181',
        fontSize: '14px',
        marginTop: '10px',
        minHeight: '20px'
      }
    }
  };

  async function hashPassword(password) {
    const encoder = new TextEncoder();
    const data = encoder.encode(password);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  }

  function applyStyles(element, styles) {
    Object.assign(element.style, styles);
  }

  function createLoginOverlay() {
    const overlay = document.createElement('div');
    overlay.id = 'passwordProtectionOverlay';
    applyStyles(overlay, CONFIG.styles.overlay);

    const container = document.createElement('div');
    applyStyles(container, CONFIG.styles.container);

    const title = document.createElement('h2');
    title.textContent = 'Enter Password';
    applyStyles(title, CONFIG.styles.title);

    const input = document.createElement('input');
    input.type = 'password';
    input.id = 'passwordProtectionInput';
    input.placeholder = 'Password';
    applyStyles(input, CONFIG.styles.input);

    input.addEventListener('focus', () => {
      applyStyles(input, CONFIG.styles.inputFocus);
    });
    input.addEventListener('blur', () => {
      input.style.borderColor = '#4a5568';
      input.style.boxShadow = 'none';
    });

    const button = document.createElement('button');
    button.textContent = 'Login';
    button.id = 'passwordProtectionButton';
    applyStyles(button, CONFIG.styles.button);

    button.addEventListener('mouseenter', () => {
      applyStyles(button, CONFIG.styles.buttonHover);
    });
    button.addEventListener('mouseleave', () => {
      button.style.transform = 'translateY(0)';
      button.style.boxShadow = 'none';
    });

    const errorMsg = document.createElement('div');
    errorMsg.id = 'passwordProtectionError';
    applyStyles(errorMsg, CONFIG.styles.error);

    container.appendChild(title);
    container.appendChild(input);
    container.appendChild(button);
    container.appendChild(errorMsg);
    overlay.appendChild(container);

    return { overlay, input, button, errorMsg };
  }

  async function checkPassword(input, errorMsg, overlay) {
    const password = input.value;
    
    if (!password) {
      errorMsg.textContent = 'Please enter a password';
      return;
    }

    try {
      const hash = await hashPassword(password);
      
      if (hash === CONFIG.expectedHash) {
        // ✅ Save expiry timestamp
        const expiry = Date.now() + CONFIG.expiryDays * 24 * 60 * 60 * 1000;
        localStorage.setItem('passwordVerifiedUntil', expiry.toString());

        overlay.style.display = 'none';
        document.body.style.overflow = 'auto';
        input.value = '';
        setTimeout(() => {
          if (overlay.parentNode) {
            overlay.parentNode.removeChild(overlay);
          }
        }, 500);
      } else {
        errorMsg.textContent = 'Incorrect password';
        input.value = '';
        input.focus();
        input.style.animation = 'shake 0.5s ease-in-out';
        setTimeout(() => {
          input.style.animation = '';
        }, 500);
      }
    } catch (error) {
      console.error('Password checking error:', error);
      errorMsg.textContent = 'An error occurred. Please try again.';
    }
  }

  function addShakeAnimation() {
    const style = document.createElement('style');
    style.textContent = `
      @keyframes shake {
        0%, 20%, 40%, 60%, 80%, 100% { transform: translateX(0); }
        10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
      }
    `;
    document.head.appendChild(style);
  }

  function initializePasswordProtection() {
    // ✅ Check expiry timestamp
    const expiry = localStorage.getItem('passwordVerifiedUntil');
    if (expiry && Date.now() < parseInt(expiry, 10)) {
      return; // still valid, skip overlay
    } else {
      localStorage.removeItem('passwordVerifiedUntil'); // expired → reset
    }

    document.body.style.visibility = 'hidden';
    document.body.style.overflow = 'hidden';
    
    const { overlay, input, button, errorMsg } = createLoginOverlay();
    document.body.appendChild(overlay);
    
    document.body.style.visibility = 'visible';
    
    button.addEventListener('click', () => {
      checkPassword(input, errorMsg, overlay);
    });
    
    input.addEventListener('keypress', (event) => {
      if (event.key === 'Enter') {
        checkPassword(input, errorMsg, overlay);
      }
    });
    
    setTimeout(() => {
      input.focus();
    }, 100);
    
    addShakeAnimation();
  }

  // ✅ Optional logout function
  window.logoutPasswordProtection = function() {
    localStorage.removeItem('passwordVerifiedUntil');
    location.reload();
  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializePasswordProtection);
  } else {
    initializePasswordProtection();
  }

})();
</script>

  <style>
    .gradient-bg {
      background: #f3f4f6;
    }
    
    .gradient-text {
      background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .import-button {
      background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
    }
    
    .import-button:hover {
      box-shadow: 0 5px 15px rgba(59, 130, 246, 0.4);
    }
    
    .generate-button {
      background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
    }
    
    .download-button {
      background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
    }
    
    #canvas {
      max-width: 100%;
      height: auto;
    }

    /* Style for the drag-over state */
    .drag-over {
        border-color: #3b82f6 !important;
        background-color: #e0f2fe !important;
    }
  </style>
</head>
<body class="min-h-screen gradient-bg p-4 font-['Fira_Sans']">
  <div class="max-w-5xl mx-auto">
    <div class="text-gray-800 text-center py-2 mb-3">
      <h1 class="text-4xl font-extrabold">Watermarker LM + Overlay</h1>
    </div>

    <div class="rounded-3xl overflow-hidden">
      <div class="grid lg:grid-cols-[320px_1fr] gap-4 p-4">
        <div class="bg-white p-5 rounded-2xl shadow-lg border border-gray-200">
          <div id="imageDropZone" class="border-4 border-dotted border-gray-400 rounded-2xl p-5 text-center mb-4 bg-gradient-to-br from-gray-50 to-gray-100 transition-all duration-300 cursor-pointer hover:border-gray-500 hover:shadow-lg hover:-translate-y-1">
              <input type="file" id="imageUpload" accept="image/*" class="hidden" />
              <p class="text-base text-gray-600 font-bold mb-3">Drag & Drop your image here</p>
              <button type="button" onclick="document.getElementById('imageUpload').click()" class="import-button text-white px-4 py-2 rounded-full font-bold transition-all duration-300 hover:-translate-y-1 text-sm">or Click to Select Image</button>
              <div class="mt-3 p-3 bg-gray-100 rounded-xl text-xs text-gray-600 leading-relaxed">
                <span class="text-blue-600 font-bold">Pro Tip:</span> You can also paste images directly! Copy an image (Ctrl+C or Cmd+C) and paste it here (Ctrl+V or Cmd+V).
              </div>
          </div>
          
          <div class="mb-4">
              <label for="overlayImageUpload" class="block font-bold text-gray-600 mb-2 text-xs">
                  Optional Image Overlay
              </label>
              <input type="file" id="overlayImageUpload" accept="image/*" class="w-full px-3 py-2 border-2 border-gray-300 rounded-xl focus:border-blue-500 focus:ring-4 focus:ring-blue-100 transition-all duration-300 text-sm" />
              <div class="mt-2 flex items-center">
                  <input type="checkbox" id="showOverlay" checked class="form-checkbox h-4 w-4 text-blue-600 transition duration-150 ease-in-out" />
                  <label for="showOverlay" class="ml-2 block text-sm text-gray-700">Show Overlay</label>
              </div>
          </div>

          <button type="button" id="imageSizeMode" class="w-full px-4 py-2 mb-4 border-2 border-gray-300 rounded-xl font-bold transition-all duration-300 hover:border-blue-500 hover:bg-blue-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-1 text-sm">
            Fill Frame (Cover)
          </button>

          <div id="imagePositionControls" class="space-y-3 mb-4">
            <div>
              <label for="imageOffsetX" class="block font-bold text-gray-600 mb-1 text-xs">Image X Offset:</label>
              <input type="range" id="imageOffsetX" min="-500" max="500" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
              <div class="text-xs text-gray-500 text-right"><span id="imageOffsetXValue">0</span> px</div>
            </div>
            <div>
              <label for="imageOffsetY" class="block font-bold text-gray-600 mb-1 text-xs">Image Y Offset:</label>
              <input type="range" id="imageOffsetY" min="-500" max="500" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
              <div class="text-xs text-gray-500 text-right"><span id="imageOffsetYValue">0</span> px</div>
            </div>
            <div>
              <label for="imageZoom" class="block font-bold text-gray-600 mb-1 text-xs">Image Zoom:</label>
              <input type="range" id="imageZoom" min="1" max="500" value="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
              <div class="text-xs text-gray-500 text-right"><span id="imageZoomValue">100</span>%</div>
            </div>
          </div>
          
          <div id="overlayFrameControls" class="space-y-3 mb-4">
              <div class="flex items-center">
                  <input type="checkbox" id="showOverlayFrame" checked class="form-checkbox h-4 w-4 text-blue-600 transition duration-150 ease-in-out" />
                  <label for="showOverlayFrame" class="ml-2 block text-sm text-gray-700 font-bold">Show Overlay in a Circle Frame</label>
              </div>
              <div class="flex items-center space-x-2">
                  <input type="checkbox" id="editFrameMode" checked class="form-checkbox h-4 w-4 text-blue-600 transition duration-150 ease-in-out" />
                  <label for="editFrameMode" class="block text-xs text-gray-600">Edit Frame Placement</label>
              </div>
              <div>
                <label for="overlayOffsetX" class="block font-bold text-gray-600 mb-1 text-xs">Overlay X:</label>
                <input type="range" id="overlayOffsetX" min="0" max="1000" value="800" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                <div class="text-xs text-gray-500 text-right"><span id="overlayOffsetXValue">800</span> px</div>
              </div>
              <div>
                <label for="overlayOffsetY" class="block font-bold text-gray-600 mb-1 text-xs">Overlay Y:</label>
                <input type="range" id="overlayOffsetY" min="0" max="500" value="200" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                <div class="text-xs text-gray-500 text-right"><span id="overlayOffsetYValue">200</span> px</div>
              </div>
              <div>
                <label for="overlayZoom" class="block font-bold text-gray-600 mb-1 text-xs">Overlay Zoom/Diameter:</label>
                <input type="range" id="overlayZoom" min="50" max="500" value="200" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                <div class="text-xs text-gray-500 text-right"><span id="overlayZoomValue">200</span> px</div>
              </div>
          </div>

          <div class="space-y-4">
            <div>
              <textarea id="title" rows="3" placeholder="Main title here..." maxlength="200" class="w-full px-3 py-2 border-2 border-gray-300 rounded-xl focus:border-blue-500 focus:ring-4 focus:ring-blue-100 transition-all duration-300 resize-y min-h-[60px] text-sm"></textarea>
            </div>

            <div>
              <select id="placement" class="w-full px-3 py-2 border-2 border-gray-300 rounded-xl focus:border-blue-500 focus:ring-4 focus:ring-blue-100 transition-all duration-300 text-sm">
                <option value="" disabled>Placement</option>
                <option value="1">Top Left</option>
                <option value="3" selected>Bottom Left</option>
                <option value="5">Top Center</option>
                <option value="6">Bottom Center</option>
              </select>
            </div>

            <div class="grid grid-cols-2 gap-2">
                <div>
                    <label class="block font-bold text-gray-600 mb-1 text-xs">Background Color:</label>
                    <div class="flex gap-2">
                        <input type="color" id="backgroundColorPicker" value="#000000" class="w-1/2 h-8 border-2 border-gray-300 rounded-md cursor-pointer" />
                        <select id="backgroundColorPresets" class="w-1/2 px-2 py-1 border-2 border-gray-300 rounded-xl focus:border-blue-500 focus:ring-4 focus:ring-blue-100 transition-all duration-300 text-sm">
                            <option value="#000000" selected>Default Black</option>
                            <option value="#DD3333">Our Red</option>
                            <option value="#00BFFF">Deep Sky Blue</option>
                        </select>
                    </div>
                </div>
                <div>
                    <label class="block font-bold text-gray-600 mb-1 text-xs">Background Blend Mode:</label>
                    <select id="backgroundBlendMode" class="w-full px-3 py-2 border-2 border-gray-300 rounded-xl focus:border-blue-500 focus:ring-4 focus:ring-blue-100 transition-all duration-300 text-sm">
                        <option value="source-over" selected>Normal</option>
                        <option value="multiply">Multiply</option>
                        <option value="screen">Screen</option>
                        <option value="overlay">Overlay</option>
                        <option value="darken">Darken</option>
                        <option value="lighten">Lighten</option>
                        </select>
                </div>
            </div>

            <div class="grid grid-cols-2 gap-2">
              <div>
                <label class="block font-bold text-gray-600 mb-1 text-xs">Title Size (px):</label>
                <input type="number" id="titleSize" value="80" min="36" max="120" placeholder="Title size" class="w-full px-3 py-2 border-2 border-gray-300 rounded-xl focus:border-blue-500 focus:ring-4 focus:ring-blue-100 transition-all duration-300 text-sm" />
              </div>
              <div class="col-span-1"></div> </div>

            <div class="flex gap-3 pt-4">
              <button onclick="drawCanvas()" class="generate-button flex-1 text-white px-4 py-3 rounded-xl font-bold transition-all duration-300 hover:-translate-y-1 hover:shadow-lg text-sm">Generate Image</button>
              <button onclick="downloadImage()" class="download-button flex-1 text-white px-4 py-3 rounded-xl font-bold transition-all duration-300 hover:-translate-y-1 hover:shadow-lg text-sm">Download Image</button>
            </div>
          </div>
        </div>

        <div class="flex justify-center items-start">
          <canvas id="canvas" width="1000" height="500" class="rounded-xl shadow-xl bg-white"></canvas>
        </div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const imageInput = document.getElementById('imageUpload');
    const overlayImageInput = document.getElementById('overlayImageUpload');
    const showOverlayCheckbox = document.getElementById('showOverlay');
    const showOverlayFrameCheckbox = document.getElementById('showOverlayFrame');
    const editFrameModeCheckbox = document.getElementById('editFrameMode');
    const titleInput = document.getElementById('title');
    const placementInput = document.getElementById('placement');
    const titleSizeInput = document.getElementById('titleSize');

    const backgroundColorPicker = document.getElementById('backgroundColorPicker');
    const backgroundColorPresets = document.getElementById('backgroundColorPresets');
    const backgroundBlendMode = document.getElementById('backgroundBlendMode');

    const imageSizeModeButton = document.getElementById('imageSizeMode');
    let imageCoverMode = false;

    const imageOffsetXInput = document.getElementById('imageOffsetX');
    const imageOffsetYInput = document.getElementById('imageOffsetY');
    const imageZoomInput = document.getElementById('imageZoom');
    const imageOffsetXValueSpan = document.getElementById('imageOffsetXValue');
    const imageOffsetYValueSpan = document.getElementById('imageOffsetYValue');
    const imageZoomValueSpan = document.getElementById('imageZoomValue');

    const overlayOffsetXInput = document.getElementById('overlayOffsetX');
    const overlayOffsetYInput = document.getElementById('overlayOffsetY');
    const overlayZoomInput = document.getElementById('overlayZoom');
    const overlayOffsetXValueSpan = document.getElementById('overlayOffsetXValue');
    const overlayOffsetYValueSpan = document.getElementById('overlayOffsetYValue');
    const overlayZoomValueSpan = document.getElementById('overlayZoomValue');

    let uploadedImage = null;
    let uploadedOverlayImage = null;
    let currentImageOffsetX = 0;
    let currentImageOffsetY = 0;
    let currentImageZoom = 100;
    
    // Default values for the overlay frame
    const defaultOverlayX = 800; // 1000 - 200 (padding)
    const defaultOverlayY = 200; // 200 (padding)
    const defaultOverlayZoom = 200; // 200px diameter

    let currentOverlayOffsetX = defaultOverlayX;
    let currentOverlayOffsetY = defaultOverlayY;
    let currentOverlayZoom = defaultOverlayZoom;

    let innerOverlayImageOffsetX = 0;
    let innerOverlayImageOffsetY = 0;
    let innerOverlayImageZoom = 100;

    // Load watermark images (fixed)
    const watermarkLogo = new Image();
    watermarkLogo.src = 'assets/logo.png';
    let watermarkLogoLoaded = false;
    watermarkLogo.onload = () => {
      watermarkLogoLoaded = true;
      drawCanvas();
    };
    watermarkLogo.onerror = () => {
      console.warn("Watermark logo (assets/logo.png) failed to load. Please ensure the path is correct.");
      watermarkLogoLoaded = false;
      drawCanvas();
    };

    const watermarkAsset2 = new Image();
    watermarkAsset2.src = 'assets/Asset 2@1.png';
    let watermarkAsset2Loaded = false;
    watermarkAsset2.onload = () => {
      watermarkAsset2Loaded = true;
      drawCanvas();
    };
    watermarkAsset2.onerror = () => {
      console.warn("Watermark Asset 2 (assets/Asset 2@1.png) failed to load. Please ensure the path is correct.");
      watermarkAsset2Loaded = false;
      drawCanvas();
    };

    function handlePaste(e) {
      const items = e.clipboardData?.items;
      if (!items) return;

      for (let item of items) {
        if (item.type.startsWith('image/')) {
          e.preventDefault();
          const file = item.getAsFile();
          if (file) {
            loadImageFromFile(file, 'main');
          }
          break;
        }
      }
    }

    function loadImageFromFile(file, type) {
      if (!file.type.startsWith('image/')) {
        alert("Please upload an image file (e.g., JPEG, PNG, GIF).");
        return;
      }

      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = () => {
          if (type === 'main') {
            uploadedImage = img;
            resetImageOffsets();
          } else if (type === 'overlay') {
            uploadedOverlayImage = img;
          }
          drawCanvas();
        };
        img.onerror = () => {
          alert("Could not load image. Please try another file.");
          if (type === 'main') {
            uploadedImage = null;
          } else if (type === 'overlay') {
            uploadedOverlayImage = null;
          }
          drawCanvas();
        };
        img.src = reader.result;
      };
      reader.readAsDataURL(file);
    }
    
    document.addEventListener('paste', handlePaste);
    document.getElementById('imageDropZone').addEventListener('paste', handlePaste);
    document.getElementById('imageDropZone').setAttribute('tabindex', '0');

    const imageDropZone = document.getElementById('imageDropZone');
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      imageDropZone.addEventListener(eventName, preventDefaults, false);
      document.body.addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults (e) {
      e.preventDefault();
      e.stopPropagation();
    }

    ['dragenter', 'dragover'].forEach(eventName => {
      imageDropZone.addEventListener(eventName, highlight, false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
      imageDropZone.addEventListener(eventName, unhighlight, false);
    });

    function highlight() {
      imageDropZone.classList.add('drag-over');
    }

    function unhighlight() {
      imageDropZone.classList.remove('drag-over');
    }

    imageDropZone.addEventListener('drop', handleDrop, false);

    function handleDrop(e) {
      const dt = e.dataTransfer;
      const files = dt.files;

      if (files.length > 0) {
        loadImageFromFile(files[0], 'main');
      }
    }

    imageInput.addEventListener('change', (e) => {
      const file = e.target.files?.[0];
      if (!file) {
        uploadedImage = null;
        drawCanvas();
        return;
      }
      loadImageFromFile(file, 'main');
    });

    overlayImageInput.addEventListener('change', (e) => {
        const file = e.target.files?.[0];
        if (!file) {
            uploadedOverlayImage = null;
            drawCanvas();
            return;
        }
        loadImageFromFile(file, 'overlay');
    });

    showOverlayCheckbox.addEventListener('change', drawCanvas);
    showOverlayFrameCheckbox.addEventListener('change', drawCanvas);

    [
      titleInput, placementInput, titleSizeInput,
      backgroundColorPicker, backgroundColorPresets, backgroundBlendMode
    ].forEach(el => {
      el.addEventListener('input', drawCanvas);
    });

    imageSizeModeButton.addEventListener('click', () => {
      imageCoverMode = !imageCoverMode;
      imageSizeModeButton.textContent = imageCoverMode ? 'Fit to Frame' : 'Fill Frame (Cover)';
      drawCanvas();
    });

    function resetImageOffsets() {
        currentImageOffsetX = 0;
        currentImageOffsetY = 0;
        currentImageZoom = 100;
        imageOffsetXInput.value = 0;
        imageOffsetYInput.value = 0;
        imageZoomInput.value = 100;
        imageOffsetXValueSpan.textContent = 0;
        imageOffsetYValueSpan.textContent = 0;
        imageZoomValueSpan.textContent = 100;

        currentOverlayOffsetX = defaultOverlayX;
        currentOverlayOffsetY = defaultOverlayY;
        currentOverlayZoom = defaultOverlayZoom;
        overlayOffsetXInput.value = defaultOverlayX;
        overlayOffsetYInput.value = defaultOverlayY;
        overlayZoomInput.value = defaultOverlayZoom;
        overlayOffsetXValueSpan.textContent = defaultOverlayX;
        overlayOffsetYValueSpan.textContent = defaultOverlayY;
        overlayZoomValueSpan.textContent = defaultOverlayZoom;
        
        innerOverlayImageOffsetX = 0;
        innerOverlayImageOffsetY = 0;
        innerOverlayImageZoom = 100;
        editFrameModeCheckbox.checked = true;
        updateSliderLabels();
    }

    function updateSliderLabels() {
        const isFrameMode = editFrameModeCheckbox.checked;
        if (isFrameMode) {
            document.querySelector('label[for="overlayOffsetX"]').textContent = 'Overlay X:';
            document.querySelector('label[for="overlayOffsetY"]').textContent = 'Overlay Y:';
            document.querySelector('label[for="overlayZoom"]').textContent = 'Overlay Frame Diameter:';
            overlayOffsetXInput.min = 0;
            overlayOffsetXInput.max = 1000;
            overlayOffsetYInput.min = 0;
            overlayOffsetYInput.max = 500;
            overlayZoomInput.min = 50;
            overlayZoomInput.max = 500;
        } else {
            document.querySelector('label[for="overlayOffsetX"]').textContent = 'Image X Offset:';
            document.querySelector('label[for="overlayOffsetY"]').textContent = 'Image Y Offset:';
            document.querySelector('label[for="overlayZoom"]').textContent = 'Image Zoom:';
            overlayOffsetXInput.min = -200;
            overlayOffsetXInput.max = 200;
            overlayOffsetYInput.min = -200;
            overlayOffsetYInput.max = 200;
            overlayZoomInput.min = 10;
            overlayZoomInput.max = 500;
        }
    }

    imageOffsetXInput.addEventListener('input', (e) => {
        currentImageOffsetX = parseInt(e.target.value);
        imageOffsetXValueSpan.textContent = currentImageOffsetX;
        drawCanvas();
    });

    imageOffsetYInput.addEventListener('input', (e) => {
        currentImageOffsetY = parseInt(e.target.value);
        imageOffsetYValueSpan.textContent = currentImageOffsetY;
        drawCanvas();
    });

    imageZoomInput.addEventListener('input', (e) => {
        currentImageZoom = parseInt(e.target.value);
        imageZoomValueSpan.textContent = currentImageZoom;
        drawCanvas();
    });

    overlayOffsetXInput.addEventListener('input', (e) => {
        const isFrameMode = editFrameModeCheckbox.checked;
        if (isFrameMode) {
            currentOverlayOffsetX = parseInt(e.target.value);
            overlayOffsetXValueSpan.textContent = currentOverlayOffsetX;
        } else {
            innerOverlayImageOffsetX = parseInt(e.target.value);
            overlayOffsetXValueSpan.textContent = innerOverlayImageOffsetX;
        }
        drawCanvas();
    });

    overlayOffsetYInput.addEventListener('input', (e) => {
        const isFrameMode = editFrameModeCheckbox.checked;
        if (isFrameMode) {
            currentOverlayOffsetY = parseInt(e.target.value);
            overlayOffsetYValueSpan.textContent = currentOverlayOffsetY;
        } else {
            innerOverlayImageOffsetY = parseInt(e.target.value);
            overlayOffsetYValueSpan.textContent = innerOverlayImageOffsetY;
        }
        drawCanvas();
    });

    overlayZoomInput.addEventListener('input', (e) => {
        const isFrameMode = editFrameModeCheckbox.checked;
        if (isFrameMode) {
            currentOverlayZoom = parseInt(e.target.value);
            overlayZoomValueSpan.textContent = currentOverlayZoom;
        } else {
            innerOverlayImageZoom = parseInt(e.target.value);
            overlayZoomValueSpan.textContent = innerOverlayImageZoom;
        }
        drawCanvas();
    });

    editFrameModeCheckbox.addEventListener('change', () => {
        updateSliderLabels();
        const isFrameMode = editFrameModeCheckbox.checked;
        if (isFrameMode) {
            overlayOffsetXInput.value = currentOverlayOffsetX;
            overlayOffsetYInput.value = currentOverlayOffsetY;
            overlayZoomInput.value = currentOverlayZoom;
            overlayOffsetXValueSpan.textContent = currentOverlayOffsetX;
            overlayOffsetYValueSpan.textContent = currentOverlayOffsetY;
            overlayZoomValueSpan.textContent = currentOverlayZoom;
        } else {
            overlayOffsetXInput.value = innerOverlayImageOffsetX;
            overlayOffsetYInput.value = innerOverlayImageOffsetY;
            overlayZoomInput.value = innerOverlayImageZoom;
            overlayOffsetXValueSpan.textContent = innerOverlayImageOffsetX;
            overlayOffsetYValueSpan.textContent = innerOverlayImageOffsetY;
            overlayZoomValueSpan.textContent = innerOverlayImageZoom;
        }
        drawCanvas();
    });

    backgroundColorPicker.addEventListener('input', () => {
        const selectedValue = backgroundColorPicker.value.toUpperCase();
        let found = false;
        for (let i = 0; i < backgroundColorPresets.options.length; i++) {
            if (backgroundColorPresets.options[i].value.toUpperCase() === selectedValue) {
                backgroundColorPresets.selectedIndex = i;
                found = true;
                break;
            }
        }
        if (!found) {
            backgroundColorPresets.selectedIndex = -1;
        }
        drawCanvas();
    });

    backgroundColorPresets.addEventListener('change', () => {
        backgroundColorPicker.value = backgroundColorPresets.value;
        drawCanvas();
    });

    function hexToRgb(hex) {
        const bigint = parseInt(hex.slice(1), 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        return [r, g, b];
    }

    function drawCanvas() {
      // 1. Clear the entire canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (!uploadedImage) {
        ctx.fillStyle = '#ccc';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#444';
        ctx.font = "700 36px 'Fira Sans', sans-serif";
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText("Drag & Drop, Click to Upload, or Paste Image", canvas.width / 2, canvas.height / 2);
        ctx.textAlign = 'left'; 
        ctx.textBaseline = 'top';
        return;
      }
      
      const imgRatio = uploadedImage.width / uploadedImage.height;
      const canvasRatio = canvas.width / canvas.height;
      const zoomFactor = currentImageZoom / 100;

      // --- LAYER 1: Blur Background (BOTTOM-MOST LAYER) ---
      ctx.save();
      if (!imageCoverMode) {
          ctx.filter = 'blur(30px)';
          let blurImgW = canvas.width, blurImgH = canvas.height;
          if (imgRatio < canvasRatio) { 
              blurImgH = canvas.width / imgRatio;
              blurImgW = canvas.width;
          } else { 
              blurImgW = canvas.height * imgRatio;
              blurImgH = canvas.height;
          }
          blurImgW *= zoomFactor;
          blurImgH *= zoomFactor;
          ctx.drawImage(uploadedImage, (canvas.width - blurImgW) / 2, (canvas.height - blurImgH) / 2, blurImgW, blurImgH);
          ctx.filter = 'none';
      }
      ctx.restore();

      // --- LAYER 2: Main Sharp Image ---
      ctx.save();
      let mainImgW, mainImgH;

      if (imageCoverMode) {
        if (imgRatio > canvasRatio) { 
          mainImgH = canvas.height;
          mainImgW = mainImgH * imgRatio;
        } else { 
          mainImgW = canvas.width;
          mainImgH = mainImgW / imgRatio;
        }
      } else {
        if (imgRatio < canvasRatio) { 
          mainImgH = canvas.height;
          mainImgW = mainImgH * imgRatio;
        } else { 
          mainImgW = canvas.width;
          mainImgH = mainImgW / imgRatio; 
        }
      }
      
      mainImgW *= zoomFactor;
      mainImgH *= zoomFactor;

      let mainImgX = (canvas.width - mainImgW) / 2 + currentImageOffsetX;
      let mainImgY = (canvas.height - mainImgH) / 2 + currentImageOffsetY;

      ctx.drawImage(uploadedImage, mainImgX, mainImgY, mainImgW, mainImgH);
      
      ctx.fillStyle = 'rgba(0,0,0,0.1)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.restore();

      // --- LAYER 3: Optional Overlay Image with/without Frame ---
      if (uploadedOverlayImage && showOverlayCheckbox.checked) {
          if (showOverlayFrameCheckbox.checked) {
              ctx.save();
              const centerX = currentOverlayOffsetX;
              const centerY = currentOverlayOffsetY;
              const radius = currentOverlayZoom / 2;

              // Apply subtle shadow to the circle
              ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';
              ctx.shadowBlur = 15;
              ctx.shadowOffsetX = 5;
              ctx.shadowOffsetY = 5;

              // Create a circular clipping path
              ctx.beginPath();
              ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
              ctx.closePath();
              ctx.clip();
              
              // Reset shadow for the image inside the frame
              ctx.shadowColor = 'transparent';
              ctx.shadowBlur = 0;
              ctx.shadowOffsetX = 0;
              ctx.shadowOffsetY = 0;

              // Draw image to fill the circular frame (cover mode)
              const overlayImgRatio = uploadedOverlayImage.width / uploadedOverlayImage.height;
              const frameRatio = 1; 

              let destWidth, destHeight;
              const zoomFactorInner = innerOverlayImageZoom / 100;
              
              if (overlayImgRatio > frameRatio) {
                  destHeight = radius * 2 * zoomFactorInner;
                  destWidth = destHeight * overlayImgRatio;
              } else {
                  destWidth = radius * 2 * zoomFactorInner;
                  destHeight = destWidth / overlayImgRatio;
              }
              const destX = centerX - destWidth / 2 + innerOverlayImageOffsetX;
              const destY = centerY - destHeight / 2 + innerOverlayImageOffsetY;
              
              ctx.drawImage(uploadedOverlayImage, destX, destY, destWidth, destHeight);
              ctx.restore();
          } else {
              // Draw the entire overlay image without a frame, centered
              ctx.save();
              ctx.drawImage(uploadedOverlayImage, (canvas.width - uploadedOverlayImage.width) / 2, (canvas.height - uploadedOverlayImage.height) / 2);
              ctx.restore();
          }
      }

      // --- LAYER 4: Placement-Specific Gradient Overlay ---
      const titleRaw = titleInput.value.trim();
      const placement = parseInt(placementInput.value);
      let titleSize = parseInt(titleSizeInput.value);

      const maxTextWidth = canvas.width - 200;

      let titleLines = [];
      function wrapTitleLines() {
        titleLines = [];
        let line = '';
        ctx.font = `800 ${titleSize}px 'Fira Sans', sans-serif`;
        const words = titleRaw.split(' ');
        for (let word of words) {
          const test = line + word + ' ';
          if (ctx.measureText(test).width > maxTextWidth && line !== '') {
            titleLines.push(line.trim());
            line = word + ' ';
          } else {
            line = test;
          }
        }
        if (line) titleLines.push(line.trim());
        return titleLines.length;
      }

      while (wrapTitleLines() > 4 && titleSize > 36) {
        titleSize -= 2;
      }

      const updatedTitleLineHeight = titleSize * 1.05;
      let textBlockHeight = titleLines.length * updatedTitleLineHeight;

      const placementMap = {
        1: { x: 50, align: 'left', y: 50 }, 
        3: { x: 50, align: 'left', y: 0 },  
        5: { x: canvas.width / 2, align: 'center', y: 50 }, 
        6: { x: canvas.width / 2, align: 'center', y: 0 } 
      };

      let posX = placementMap?.[placement]?.x ?? 50; 
      let align = placementMap?.[placement]?.align ?? 'left';
      let posY = placementMap?.[placement]?.y ?? 50; 

      const watermarkAreaHeight = Math.max(
          (watermarkLogoLoaded ? 49 : 0), 
          (watermarkAsset2Loaded ? 42 : 0) 
      );
      const bottomOffsetForText = 35 + watermarkAreaHeight + 10; 
      if (placement === 3 || placement === 6) {
        posY = canvas.height - bottomOffsetForText - textBlockHeight;
      }

      const gradientPadding = 150;
      let gradient;

      const selectedBgColorHex = backgroundColorPicker.value;
      const selectedBlendMode = backgroundBlendMode.value;
      const [r, g, b] = hexToRgb(selectedBgColorHex);

      ctx.save(); 
      ctx.globalCompositeOperation = selectedBlendMode; 

      if (placement === 1 || placement === 5) {
        const gradientEndY = posY + textBlockHeight + gradientPadding;
        gradient = ctx.createLinearGradient(0, 0, 0, gradientEndY);
        
        gradient.addColorStop(0, `rgba(${r},${g},${b},0.4)`); 
        gradient.addColorStop(0.6, `rgba(${r},${g},${b},0.2)`); 
        gradient.addColorStop(1, `rgba(${r},${g},${b},0)`);
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, gradientEndY);
      } else if (placement === 3 || placement === 6) {
        const gradientStartY = posY - gradientPadding;
        gradient = ctx.createLinearGradient(0, gradientStartY, 0, canvas.height);
        
        gradient.addColorStop(0, `rgba(${r},${g},${b},0)`);
        gradient.addColorStop(0.4, `rgba(${r},${g},${b},0.2)`); 
        gradient.addColorStop(1, `rgba(${r},${g},${b},0.4)`); 
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, gradientStartY, canvas.width, canvas.height - gradientStartY);
      }
      
      ctx.restore(); 

      // --- LAYER 5: Watermarks (Logos) ---
      const watermarkBottomPadding = 35; 
      const watermarkLeftPadding = 50;
      const watermarkSpacing = 10; 

      let currentWatermarkX = watermarkLeftPadding;
      let watermarkBaseY = canvas.height - watermarkBottomPadding; 

      ctx.save(); 

      if (watermarkAsset2Loaded) {
          const asset2Height = 42; 
          const asset2Width = watermarkAsset2.width * (asset2Height / watermarkAsset2.height);
          ctx.globalAlpha = 1.0; 
          const asset2Y = watermarkBaseY - asset2Height; 
          ctx.drawImage(watermarkAsset2, currentWatermarkX, asset2Y, asset2Width, asset2Height);
          currentWatermarkX += asset2Width + watermarkSpacing; 
      }

      if (watermarkLogoLoaded) {
          const logoHeight = 49; 
          const logoWidth = watermarkLogo.width * (logoHeight / watermarkLogo.height);
          ctx.globalAlpha = 1.0; 
          const logoY = watermarkBaseY - logoHeight;
          ctx.drawImage(watermarkLogo, currentWatermarkX, logoY, logoWidth, logoHeight);
      }
      ctx.restore(); 

      // --- LAYER 6: Main Title Text (TOP-MOST LAYER) ---
      ctx.textAlign = align;
      ctx.textBaseline = 'top';
      ctx.shadowColor = 'rgba(0,0,0,0.4)';
      ctx.shadowBlur = 4;
      ctx.shadowOffsetX = 2;
      ctx.shadowOffsetY = 2;

      let currentTextY = posY;

      ctx.fillStyle = 'white';
      ctx.font = `800 ${titleSize}px 'Fira Sans', sans-serif`;
      for (let i = 0; i < titleLines.length; i++) {
        ctx.fillText(titleLines?.[i] ?? '', posX, currentTextY + i * updatedTitleLineHeight);
      }

      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;
    }

    function downloadImage() {
      const buttonContainer = document.querySelector('.flex.gap-3.pt-4');
      const downloadButton = buttonContainer.querySelector('button:last-child');
      const generateButton = buttonContainer.querySelector('button:first-child');
      const importButton = document.querySelector('.import-button');

      const originalDownloadText = downloadButton.textContent;
      downloadButton.textContent = 'Downloading...';
      downloadButton.disabled = true;
      generateButton.disabled = true;
      importButton.disabled = true;

      try {
        const link = document.createElement('a');
        link.download = 'Watermarked.webp';
        link.href = canvas.toDataURL('image/webp', 0.9);

        link.click();

        setTimeout(() => {
          downloadButton.textContent = originalDownloadText;
          downloadButton.disabled = false;
          generateButton.disabled = false;
          importButton.disabled = false;
        }, 2000);
      } catch (error) {
        console.error("Download failed:", error);
        alert("Image download failed. Please try again.");
        downloadButton.textContent = originalDownloadText;
        downloadButton.disabled = false;
        generateButton.disabled = false;
        importButton.disabled = false;
      }
    }

    window.onload = () => {
        updateSliderLabels();
        drawCanvas();
    };
  </script>
</body>
</html>